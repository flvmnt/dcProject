This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-29T11:59:18.448Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
benchmark/
  bench/
    CpuSortBenchmark.java
    DemoBenchmark.java
    FileWriteBenchmark.java
    IBenchmark.java
  logging/
    ConsoleLogger.java
    FileLogger.java
    ILogger.java
    TimeUnit.java
  timing/
    ITimer.java
    Timer.java
  Main.java
testbench/
  TestDemoBench.java

================================================================
Files
================================================================

================
File: benchmark/bench/CpuSortBenchmark.java
================
package benchmark.bench;

import java.util.Random;

public class CpuSortBenchmark implements IBenchmark {
    private double[] data;
    private volatile boolean cancelled = false;

    @Override
    public void initialize(Object... params) {
        int size = (Integer) params[0];
        data = new double[size];
        Random rnd = new Random();
        for (int i = 0; i < size; i++) {
            data[i] = rnd.nextDouble();
        }
    }

    @Override
    public void run() {
        int n = data.length;
        for (int i = 0; i < n && !cancelled; i++) {
            for (int j = 0; j < n - i - 1 && !cancelled; j++) {
                if (data[j] > data[j + 1]) {
                    double tmp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = tmp;
                }
            }
        }
    }

    @Override
    public void clean() {
        data = null;
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: benchmark/bench/DemoBenchmark.java
================
package benchmark.bench;

public class DemoBenchmark implements IBenchmark {
    private long sleepMillis;
    private volatile boolean cancelled;

    @Override
    public void initialize(Object... params) {
        sleepMillis = (Long) params[0];
        cancelled = false;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(sleepMillis);
        } catch (InterruptedException ignored) {}
    }

    @Override
    public void clean() {
        // nothing to clean
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: benchmark/bench/FileWriteBenchmark.java
================
package benchmark.bench;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class FileWriteBenchmark implements IBenchmark {
    private String filepath;
    private volatile boolean cancelled = false;

    @Override
    public void initialize(Object... params) {
        filepath = (String) params[0];
    }

    @Override
    public void run() {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(filepath))) {
            for (int i = 0; i < 1_000_000 && !cancelled; i++) {
                bw.write("Line " + i);
                bw.newLine();
            }
        } catch (IOException e) {
            throw new RuntimeException("File write failed", e);
        }
    }

    @Override
    public void clean() {
        // nothing extra
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: benchmark/bench/IBenchmark.java
================
package benchmark.bench;

public interface IBenchmark {
    /** Prepare the benchmark (e.g. generate data or open files). */
    void initialize(Object... params);
    /** The actual code whose performance is measured. */
    void run();
    /** Cleanup after run (e.g. free memory). */
    void clean();
    /** Signal cancellation (should cause run() to return as soon as possible). */
    void cancel();
}

================
File: benchmark/logging/ConsoleLogger.java
================
package benchmark.logging;

public class ConsoleLogger implements ILogger {
    @Override
    public void write(long value) {
        System.out.println(value);
    }
    @Override
    public void write(String text) {
        System.out.println(text);
    }
    @Override
    public void write(Object... values) {
        StringBuilder sb = new StringBuilder();
        for (Object v : values) sb.append(v).append(" ");
        System.out.println(sb.toString().trim());
    }
    @Override
    public void close() { /* no-op */ }
}

================
File: benchmark/logging/FileLogger.java
================
package benchmark.logging;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class FileLogger implements ILogger {
    private final BufferedWriter writer;

    public FileLogger(String filepath) throws IOException {
        this.writer = new BufferedWriter(new FileWriter(filepath));
    }

    @Override
    public void write(long value) {
        write(Long.toString(value));
    }

    @Override
    public void write(String text) {
        try {
            writer.write(text);
            writer.newLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void write(Object... values) {
        StringBuilder sb = new StringBuilder();
        for (Object v : values) sb.append(v).append(" ");
        write(sb.toString().trim());
    }

    @Override
    public void close() {
        try { writer.close(); }
        catch (IOException ignored) {}
    }
}

================
File: benchmark/logging/ILogger.java
================
package benchmark.logging;

import benchmark.logging.TimeUnit;

public interface ILogger {
    void write(long value);
    void write(String text);
    void write(Object... values);
    void close();

    /** Convert & write a time value in the given unit. */
    default void writeTime(String label, long nanos, TimeUnit unit) {
        double v = unit.fromNanos(nanos);
        write(label, String.format("%.3f", v), unit.name());
    }
}

================
File: benchmark/logging/TimeUnit.java
================
package benchmark.logging;

/** Supported units for converting nanoseconds. */
public enum TimeUnit {
    NANO   (1L),
    MICRO  (1_000L),
    MILLI  (1_000_000L),
    SECOND (1_000_000_000L);

    private final long factor;

    TimeUnit(long nanosPerUnit) {
        this.factor = nanosPerUnit;
    }

    /** Convert nanoseconds to this unit (returns a double). */
    public double fromNanos(long nanos) {
        return nanos / (double)factor;
    }
}

================
File: benchmark/timing/ITimer.java
================
package benchmark.timing;

public interface ITimer {
    /** Reset any previous time and start timing from now. */
    void start();

    /** Stop timing and return cumulative elapsed nanoseconds. */    
    long stop();
    
    // Pause timing (accumulate since last start) and return the last segmentâ€™s nanoseconds.
    long pause();

    // Resume timing after a pause.
    void resume();
}

================
File: benchmark/timing/Timer.java
================
package benchmark.timing;

public class Timer implements ITimer {
    private long startTime;
    private long elapsed;
    private boolean running;
    private boolean started;

    public Timer() {
        this.elapsed = 0;
        this.running = false;
        this.started = false;
    }

    @Override
    public void start() {
        // Always reset
        elapsed = 0;
        startTime = System.nanoTime();
        running = true;
        started = true;
    }

    @Override
    public long pause() {
        if (!started || !running) {
            throw new IllegalStateException("Cannot pause: timer is not running");
        }
        long now = System.nanoTime();
        long delta = now - startTime;
        elapsed += delta;
        running = false;
        return delta;
    }

    @Override
    public void resume() {
        if (!started) {
            throw new IllegalStateException("Cannot resume: timer has not been started");
        }
        if (running) {
            throw new IllegalStateException("Cannot resume: timer is already running");
        }
        startTime = System.nanoTime();
        running = true;
    }

    @Override
    public long stop() {
        if (!started) {
            throw new IllegalStateException("Cannot stop: timer has not been started");
        }
        if (running) {
            long now = System.nanoTime();
            elapsed += now - startTime;
            running = false;
        }
        started = false;
        return elapsed;
    }
}

================
File: benchmark/Main.java
================
package benchmark;

import benchmark.timing.Timer;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.FileLogger;
import benchmark.logging.ILogger;
import benchmark.bench.CpuSortBenchmark;
import benchmark.bench.FileWriteBenchmark;
import benchmark.bench.IBenchmark;

public class Main {
    private static void usage() {
        System.out.println("Usage:");
        System.out.println("  java -jar benchmark.jar --list");
        System.out.println("  java -jar benchmark.jar --benchmark [cpu_sort|file_write] --logger [console|file]");
        System.out.println("       [--logfile <file>] [--size <n>] [--path <file>]");
    }

    private static void listBenchmarks() {
        System.out.println("Available benchmarks:");
        System.out.println("  cpu_sort   - Bubble sort on a random array");
        System.out.println("  file_write - Write 1,000,000 lines to a file");
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            listBenchmarks();
            usage();
            return;
        }

        String benchmark = null, loggerType = null, logfile = null, path = "benchmark_output.txt";
        int size = 10_000;
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "--list":
                    listBenchmarks(); return;
                case "--benchmark":
                    benchmark = args[++i]; break;
                case "--logger":
                    loggerType = args[++i]; break;
                case "--logfile":
                    logfile = args[++i]; break;
                case "--size":
                    size = Integer.parseInt(args[++i]); break;
                case "--path":
                    path = args[++i]; break;
                default:
                    System.err.println("Unknown option: " + args[i]);
                    usage();
                    return;
            }
        }

        if (benchmark == null || loggerType == null) {
            System.err.println("Error: --benchmark and --logger are required.");
            usage();
            return;
        }

        IBenchmark bench;
        switch (benchmark) {
            case "cpu_sort":
                bench = new CpuSortBenchmark();
                bench.initialize(size);
                break;
            case "file_write":
                bench = new FileWriteBenchmark();
                bench.initialize(path);
                break;
            default:
                System.err.println("Unknown benchmark: " + benchmark);
                return;
        }

        ILogger logger;
        try {
            switch (loggerType) {
                case "console":
                    logger = new ConsoleLogger();
                    break;
                case "file":
                    if (logfile == null) {
                        System.err.println("Error: --logfile is required for file logger.");
                        return;
                    }
                    logger = new FileLogger(logfile);
                    break;
                default:
                    System.err.println("Unknown logger: " + loggerType);
                    return;
            }
        } catch (Exception e) {
            System.err.println("Failed to initialize logger: " + e.getMessage());
            return;
        }

        Timer timer = new Timer();
        timer.start();
        bench.run();
        long elapsedNs = timer.stop();
        double elapsedMs = elapsedNs / 1_000_000.0;

        logger.write("Benchmark:", benchmark);
        logger.write("Elapsed (ns):", elapsedNs);
        logger.write("Elapsed (ms):", String.format("%.3f", elapsedMs));
        logger.close();
        bench.clean();
    }
}

================
File: testbench/TestDemoBench.java
================
package testbench;

import benchmark.bench.DemoBenchmark;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.ILogger;
import benchmark.logging.TimeUnit;
import benchmark.timing.Timer;

public class TestDemoBench {
    public static void main(String[] args) {
        ILogger log = new ConsoleLogger();
        Timer t = new Timer();
        DemoBenchmark demo = new DemoBenchmark();

        long sleepMs = 100;      // expected 100 ms
        demo.initialize(sleepMs);

        // 1) measure straight sleep + offset %
        t.start();
        demo.run();
        long measuredNs = t.stop();
        double expectedNs = sleepMs * 1_000_000.0;
        double offset = 100.0 * (measuredNs - expectedNs) / expectedNs;
        log.write("Expected (ms):", sleepMs);
        log.write("Measured (ns):", measuredNs);
        log.write(String.format("Offset: %.2f%%", offset));

        // 2) test pause/resume sequence in a loop (six 100 ms sleeps)
        t.start();
        for (int i = 0; i < 6; i++) {
            t.resume();      // error if already running
            try { Thread.sleep(sleepMs); } catch(Exception ignored){}
            long delta = t.pause();
            log.write("Segment", i, "=", delta / 1_000_000.0, "ms");
        }
        long total = t.stop();   // sum of all six segments
        log.write("Total (ms):", total / 1_000_000.0);

        // 3) now demonstrate writeTime in different units:
        log.writeTime("Total in seconds:", total, TimeUnit.SECOND);
        log.writeTime("Total in millis:", total, TimeUnit.MILLI);
        log.writeTime("Total in micros:", total, TimeUnit.MICRO);
        log.close();
    }
}
