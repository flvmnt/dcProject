This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-03T10:32:15.403Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  benchmark/
    bench/
      CpuSortBenchmark.java
      DemoBenchmark.java
      FileWriteBenchmark.java
      IBenchmark.java
    cpu/
      CPUDigitsOfPi.java
      CPUFixedPoint.java
      CPUFixedVsFloatingPoint.java
      CPURecursionLoopUnrolling.java
    logging/
      ConsoleLogger.java
      FileLogger.java
      ILogger.java
      TimeUnit.java
    timing/
      ITimer.java
      Timer.java
    Main.java
  testbench/
    TestCPUDigitsOfPi.java
    TestCPUFixedPoint.java
    TestCPUFixedVsFloatingPoint.java
    TestCPURecursionLoopUnrolling.java
    TestDemoBench.java
  repomix-output.txt
.gitattributes
README.md

================================================================
Files
================================================================

================
File: src/benchmark/bench/CpuSortBenchmark.java
================
package benchmark.bench;

import java.util.Random;

public class CpuSortBenchmark implements IBenchmark {
    private double[] data;
    private volatile boolean cancelled = false;

    @Override
    public void initialize(Object... params) {
        int size = (Integer) params[0];
        data = new double[size];
        Random rnd = new Random();
        for (int i = 0; i < size; i++) {
            data[i] = rnd.nextDouble();
        }
    }

    @Override
    public void warmup() {
        initialize(1000); // small array
        run();            // run once to warm up
    }


    @Override
    public void run() {
        int n = data.length;
        for (int i = 0; i < n && !cancelled; i++) {
            for (int j = 0; j < n - i - 1 && !cancelled; j++) {
                if (data[j] > data[j + 1]) {
                    double tmp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = tmp;
                }
            }
        }
    }

    @Override
    public void clean() {
        data = null;
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: src/benchmark/bench/DemoBenchmark.java
================
package benchmark.bench;

public class DemoBenchmark implements IBenchmark {
    private long sleepMillis;
    private volatile boolean cancelled;

    @Override
    public void initialize(Object... params) {
        sleepMillis = (Long) params[0];
        cancelled = false;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(sleepMillis);
        } catch (InterruptedException ignored) {}
    }

    @Override
    public void warmup() {
        initialize(10L); // short sleep
        run();
    }

    @Override
    public void clean() {
        // nothing to clean
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: src/benchmark/bench/FileWriteBenchmark.java
================
package benchmark.bench;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class FileWriteBenchmark implements IBenchmark {
    private String filepath;
    private volatile boolean cancelled = false;

    @Override
    public void initialize(Object... params) {
        filepath = (String) params[0];
    }

    @Override
    public void warmup() {
        initialize("warmup_output.txt");
        run();
    }

    @Override
    public void run() {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(filepath))) {
            for (int i = 0; i < 1_000_000 && !cancelled; i++) {
                bw.write("Line " + i);
                bw.newLine();
            }
        } catch (IOException e) {
            throw new RuntimeException("File write failed", e);
        }
    }

    @Override
    public void clean() {
        // nothing extra
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: src/benchmark/bench/IBenchmark.java
================
package benchmark.bench;

public interface IBenchmark {
    /** Prepare the benchmark (e.g. generate data or open files). */
    void initialize(Object... params);
    /** The actual code whose performance is measured. */
    void run();
    /** Cleanup after run (e.g. free memory). */
    void clean();
    /** Signal cancellation (should cause run() to return as soon as possible). */
    void cancel();
    
    void warmup();
}

================
File: src/benchmark/cpu/CPUDigitsOfPi.java
================
// File: src/benchmark/cpu/CPUDigitsOfPi.java
package benchmark.cpu;

import benchmark.bench.IBenchmark;

import java.math.BigDecimal;
import java.math.MathContext;

public class CPUDigitsOfPi implements IBenchmark {
    private int digits;

    @Override
    public void initialize(Object... params) {
        this.digits = (Integer) params[0];
    }

    @Override
    public void run() {
        computePiArctangent(digits);
    }

    public void run(Object... options) {
        int algo = options.length > 0 ? (Integer) options[0] : 1;
        switch (algo) {
            case 1:
            default:
                computePiArctangent(digits);
        }
    }

    @Override
    public void clean() {
        // Nothing to clean for now
    }

    @Override
    public void cancel() {
        // Not used
    }

    @Override
    public void warmup() {
        computePiArctangent(1000); // small warmup workload
    }

    // Machin-like formula: pi = 16*arctan(1/5) - 4*arctan(1/239)
    private void computePiArctangent(int digits) {
        MathContext mc = new MathContext(digits + 5);
        BigDecimal arctan1_5 = arctan(5, digits, mc);
        BigDecimal arctan1_239 = arctan(239, digits, mc);
        BigDecimal pi = arctan1_5.multiply(BigDecimal.valueOf(16)).subtract(
                arctan1_239.multiply(BigDecimal.valueOf(4)));
    }

    private BigDecimal arctan(int inverseX, int digits, MathContext mc) {
        BigDecimal result = BigDecimal.ZERO;
        BigDecimal x = BigDecimal.ONE.divide(BigDecimal.valueOf(inverseX), mc);
        BigDecimal xPower = x;
        BigDecimal invX2 = x.multiply(x);
        int sign = 1;

        for (int i = 1; i < digits * 2; i += 2) {
            BigDecimal term = xPower.divide(BigDecimal.valueOf(i), mc);
            result = sign > 0 ? result.add(term) : result.subtract(term);
            xPower = xPower.multiply(invX2);
            sign *= -1;
        }
        return result;
    }
}

================
File: src/benchmark/cpu/CPUFixedPoint.java
================
package benchmark.cpu;

import benchmark.bench.IBenchmark;

public class CPUFixedPoint implements IBenchmark {
    private int[] num = { 0, 1, 2, 3 };
    private int[] a, b, c;
    private int size;

    @Override
    public void initialize(Object... params) {
        size = ((Number) params[0]).intValue();
        a = new int[size];
        b = new int[size];
        c = new int[size];
        for (int i = 0; i < size; i++) {
            a[i] = i;
            b[i] = size - i - 1;
        }
    }

    @Override
    public void run() {
        testIntegerArithmetic();
        testBranching();
        testArrayAccess();
    }

    public void run(Object... options) {
        run();
    }

    @Override
    public void clean() {
        a = b = c = null;
    }

    @Override
    public void cancel() {
    }

    @Override
    public void warmup() {
        initialize(1000);
        run();
    }

    private void testIntegerArithmetic() {
        int j = 1, k = 2, l = 3;
        for (int i = 0; i < size; i++) {
            j = num[1] * (k - j) * (l - k);
            k = num[3] * k - (l - j) * k;
            l = (l - k) * (num[2] + j);
        }
    }

    private void testBranching() {
        int j = 0;
        for (int i = 0; i < size; i++) {
            if (j == 1) j = num[2]; else j = num[3];
            if (j > 2) j = num[0]; else j = num[1];
            if (j < 1) j = num[1]; else j = num[0];
        }
    }

    private void testArrayAccess() {
        for (int i = 0; i < size; i++) {
            int index = b[i] % size;
            c[i] = a[index];
        }
    }

    public double getMOPS(long timeNs) {
        final int OPS_PER_ITER = 27; // calculate exact number in your code
        return (OPS_PER_ITER * size) / (timeNs / 1e6);
    }
}

================
File: src/benchmark/cpu/CPUFixedVsFloatingPoint.java
================
package benchmark.cpu;

import benchmark.bench.IBenchmark;

public class CPUFixedVsFloatingPoint implements IBenchmark {
    private static final int ITERATIONS = 50_000_000;
    private double resultFloat = 0.0;
    private int resultFixed = 0;

    public enum NumberRepresentation {
        FIXED, FLOATING
    }

    @Override
    public void initialize(Object... params) {
        // not used
    }

    @Override
    public void run() {
        // not used
    }

    public void run(Object... options) {
        NumberRepresentation type = (NumberRepresentation) options[0];
        if (type == NumberRepresentation.FLOATING) {
            for (int i = 1; i <= ITERATIONS; i++) {
                resultFloat += i / 256.0; // Floating point division
            }
        } else if (type == NumberRepresentation.FIXED) {
            for (int i = 1; i <= ITERATIONS; i++) {
                resultFixed += i >> 8; // Bit-shift instead of /256
            }
        }
    }

    @Override
    public void clean() {
        resultFloat = 0.0;
        resultFixed = 0;
    }

    @Override
    public void cancel() {
    }

    @Override
    public void warmup() {
        run(NumberRepresentation.FIXED);
        run(NumberRepresentation.FLOATING);
    }
}

================
File: src/benchmark/cpu/CPURecursionLoopUnrolling.java
================
// File: src/benchmark/cpu/CPURecursionLoopUnrolling.java
package benchmark.cpu;

import benchmark.bench.IBenchmark;

public class CPURecursionLoopUnrolling implements IBenchmark {
    private long lastPrime = 0;
    private int callCount = 0;
    private long startTime, endTime;

    @Override
    public void initialize(Object... params) {
        // No init needed
    }

    @Override
    public void run() {
        try {
            startTime = System.nanoTime();
            recursive(2);
        } catch (StackOverflowError e) {
            endTime = System.nanoTime();
            System.out.printf("[!] Stack overflow at recursion depth: %d\n", callCount);
            System.out.printf("[!] Last prime: %d\n", lastPrime);
            System.out.printf("[!] Runtime: %.3f seconds\n", (endTime - startTime) / 1e9);
            System.out.printf("[!] Score: %.2f\n", getScore());
        }
    }

    public long recursive(long n) {
        callCount++;
        if (isPrime(n)) lastPrime = n;
        return recursive(n + 1);
    }

    public long recursiveUnrolled(long n, int unrollLevel) {
        callCount++;
        for (int i = 0; i < unrollLevel; i++) {
            if (isPrime(n)) lastPrime = n;
            n++;
        }
        return recursiveUnrolled(n, unrollLevel);
    }

    private boolean isPrime(long n) {
        if (n < 2) return false;
        for (long i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }

    private double getScore() {
        double time = (endTime - startTime) / 1e9; // seconds
        return lastPrime / (time * callCount / 1e3 + 1); // simplistic score
    }

    @Override public void clean() {}
    @Override public void cancel() {}
    @Override public void warmup() {}
}

================
File: src/benchmark/logging/ConsoleLogger.java
================
package benchmark.logging;

public class ConsoleLogger implements ILogger {
    @Override
    public void write(long value) {
        System.out.println(value);
    }
    @Override
    public void write(String text) {
        System.out.println(text);
    }
    @Override
    public void write(Object... values) {
        StringBuilder sb = new StringBuilder();
        for (Object v : values) sb.append(v).append(" ");
        System.out.println(sb.toString().trim());
    }
    @Override
    public void close() { /* no-op */ }
}

================
File: src/benchmark/logging/FileLogger.java
================
package benchmark.logging;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class FileLogger implements ILogger {
    private final BufferedWriter writer;

    public FileLogger(String filepath) throws IOException {
        this.writer = new BufferedWriter(new FileWriter(filepath));
    }

    @Override
    public void write(long value) {
        write(Long.toString(value));
    }

    @Override
    public void write(String text) {
        try {
            writer.write(text);
            writer.newLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void write(Object... values) {
        StringBuilder sb = new StringBuilder();
        for (Object v : values) sb.append(v).append(" ");
        write(sb.toString().trim());
    }

    @Override
    public void close() {
        try { writer.close(); }
        catch (IOException ignored) {}
    }
}

================
File: src/benchmark/logging/ILogger.java
================
package benchmark.logging;

import benchmark.logging.TimeUnit;

public interface ILogger {
    void write(long value);
    void write(String text);
    void write(Object... values);
    void close();

    /** Convert & write a time value in the given unit. */
    default void writeTime(String label, long nanos, TimeUnit unit) {
        double v = unit.fromNanos(nanos);
        write(label, String.format("%.3f", v), unit.name());
    }
}

================
File: src/benchmark/logging/TimeUnit.java
================
package benchmark.logging;

/** Supported units for converting nanoseconds. */
public enum TimeUnit {
    NANO   (1L),
    MICRO  (1_000L),
    MILLI  (1_000_000L),
    SECOND (1_000_000_000L);

    private final long factor;

    TimeUnit(long nanosPerUnit) {
        this.factor = nanosPerUnit;
    }

    /** Convert nanoseconds to this unit (returns a double). */
    public double fromNanos(long nanos) {
        return nanos / (double)factor;
    }
}

================
File: src/benchmark/timing/ITimer.java
================
package benchmark.timing;

public interface ITimer {
    /** Reset any previous time and start timing from now. */
    void start();

    /** Stop timing and return cumulative elapsed nanoseconds. */    
    long stop();
    
    // Pause timing (accumulate since last start) and return the last segment’s nanoseconds.
    long pause();

    // Resume timing after a pause.
    void resume();
}

================
File: src/benchmark/timing/Timer.java
================
package benchmark.timing;

public class Timer implements ITimer {
    private long startTime;
    private long elapsed;
    private boolean running;
    private boolean started;

    public Timer() {
        this.elapsed = 0;
        this.running = false;
        this.started = false;
    }

    @Override
    public void start() {
        // Always reset
        elapsed = 0;
        startTime = System.nanoTime();
        running = true;
        started = true;
    }

    @Override
    public long pause() {
        if (!started || !running) {
            throw new IllegalStateException("Cannot pause: timer is not running");
        }
        long now = System.nanoTime();
        long delta = now - startTime;
        elapsed += delta;
        running = false;
        return delta;
    }

    @Override
    public void resume() {
        if (!started) {
            throw new IllegalStateException("Cannot resume: timer has not been started");
        }
        if (running) {
            throw new IllegalStateException("Cannot resume: timer is already running");
        }
        startTime = System.nanoTime();
        running = true;
    }

    @Override
    public long stop() {
        if (!started) {
            throw new IllegalStateException("Cannot stop: timer has not been started");
        }
        if (running) {
            long now = System.nanoTime();
            elapsed += now - startTime;
            running = false;
        }
        started = false;
        return elapsed;
    }
}

================
File: src/benchmark/Main.java
================
package benchmark;

import benchmark.timing.Timer;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.FileLogger;
import benchmark.logging.ILogger;
import benchmark.bench.CpuSortBenchmark;
import benchmark.bench.FileWriteBenchmark;
import benchmark.bench.IBenchmark;

public class Main {
    private static void usage() {
        System.out.println("Usage:");
        System.out.println("  java -jar benchmark.jar --list");
        System.out.println("  java -jar benchmark.jar --benchmark [cpu_sort|file_write] --logger [console|file]");
        System.out.println("       [--logfile <file>] [--size <n>] [--path <file>]");
    }

    private static void listBenchmarks() {
        System.out.println("Available benchmarks:");
        System.out.println("  cpu_sort   - Bubble sort on a random array");
        System.out.println("  file_write - Write 1,000,000 lines to a file");
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            listBenchmarks();
            usage();
            return;
        }

        String benchmark = null, loggerType = null, logfile = null, path = "benchmark_output.txt";
        int size = 10_000;
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "--list":
                    listBenchmarks(); return;
                case "--benchmark":
                    benchmark = args[++i]; break;
                case "--logger":
                    loggerType = args[++i]; break;
                case "--logfile":
                    logfile = args[++i]; break;
                case "--size":
                    size = Integer.parseInt(args[++i]); break;
                case "--path":
                    path = args[++i]; break;
                default:
                    System.err.println("Unknown option: " + args[i]);
                    usage();
                    return;
            }
        }

        if (benchmark == null || loggerType == null) {
            System.err.println("Error: --benchmark and --logger are required.");
            usage();
            return;
        }

        IBenchmark bench;
        switch (benchmark) {
            case "cpu_sort":
                bench = new CpuSortBenchmark();
                bench.initialize(size);
                break;
            case "file_write":
                bench = new FileWriteBenchmark();
                bench.initialize(path);
                break;
            default:
                System.err.println("Unknown benchmark: " + benchmark);
                return;
        }

        ILogger logger;
        try {
            switch (loggerType) {
                case "console":
                    logger = new ConsoleLogger();
                    break;
                case "file":
                    if (logfile == null) {
                        System.err.println("Error: --logfile is required for file logger.");
                        return;
                    }
                    logger = new FileLogger(logfile);
                    break;
                default:
                    System.err.println("Unknown logger: " + loggerType);
                    return;
            }
        } catch (Exception e) {
            System.err.println("Failed to initialize logger: " + e.getMessage());
            return;
        }

        Timer timer = new Timer();
        timer.start();
        bench.run();
        long elapsedNs = timer.stop();
        double elapsedMs = elapsedNs / 1_000_000.0;

        logger.write("Benchmark:", benchmark);
        logger.write("Elapsed (ns):", elapsedNs);
        logger.write("Elapsed (ms):", String.format("%.3f", elapsedMs));
        logger.close();
        bench.clean();
    }
}

================
File: src/testbench/TestCPUDigitsOfPi.java
================
package testbench;

import benchmark.cpu.CPUDigitsOfPi;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.ILogger;
import benchmark.logging.TimeUnit;
import benchmark.timing.Timer;

public class TestCPUDigitsOfPi {
    public static void main(String[] args) {
        CPUDigitsOfPi piBench = new CPUDigitsOfPi();
        ILogger logger = new ConsoleLogger();
        Timer timer = new Timer();

        int digits = 1000; // try 100, 500, 1000, 5000, etc.
        piBench.initialize(digits);
        piBench.warmup(); // trigger class loading, warmup JVM

        for (int i = 0; i < 5; i++) {
            timer.start();
            piBench.run();
            long time = timer.stop();
            logger.write("Run #" + (i + 1), "Time (ms):", String.format("%.3f", time / 1_000_000.0));
        }

        logger.close();
        piBench.clean();
    }
}

================
File: src/testbench/TestCPUFixedPoint.java
================
package testbench;

import benchmark.cpu.CPUFixedPoint;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.ILogger;
import benchmark.timing.Timer;

public class TestCPUFixedPoint {
    public static void main(String[] args) {
        ILogger logger = new ConsoleLogger();
        Timer timer = new Timer();
        CPUFixedPoint bench = new CPUFixedPoint();
        int size = 1_000_000;

        bench.initialize(size);
        bench.warmup();

        timer.start();
        bench.run();
        long time = timer.stop();

        double mops = bench.getMOPS(time);
        logger.write("Fixed point MOPS:", String.format("%.2f", mops / 1_000_000) + " MOPS");
        logger.close();
    }
}

================
File: src/testbench/TestCPUFixedVsFloatingPoint.java
================
package testbench;

import benchmark.cpu.CPUFixedVsFloatingPoint;
import benchmark.cpu.CPUFixedVsFloatingPoint.NumberRepresentation;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.ILogger;
import benchmark.timing.Timer;

public class TestCPUFixedVsFloatingPoint {
    public static void main(String[] args) {
        ILogger logger = new ConsoleLogger();
        Timer timer = new Timer();
        CPUFixedVsFloatingPoint bench = new CPUFixedVsFloatingPoint();

        bench.warmup();

        for (NumberRepresentation type : NumberRepresentation.values()) {
            bench.clean();
            timer.start();
            bench.run(type);
            long time = timer.stop();
            logger.write("Type: " + type, "Time (ms):", String.format("%.3f", time / 1_000_000.0));
        }

        logger.close();
    }
}

================
File: src/testbench/TestCPURecursionLoopUnrolling.java
================
package testbench;

import benchmark.cpu.CPURecursionLoopUnrolling;

public class TestCPURecursionLoopUnrolling {
    public static void main(String[] args) {
        CPURecursionLoopUnrolling benchmark = new CPURecursionLoopUnrolling();
        benchmark.run(); // runs plain recursion

        System.out.println("\n--- Loop Unrolling Test ---");
        try {
            benchmark = new CPURecursionLoopUnrolling();
            benchmark.recursiveUnrolled(2, 5); // unrollLevel = 5
        } catch (StackOverflowError e) {
            System.out.println("[!] Loop unrolling crashed as expected.");
        }
    }
}

================
File: src/testbench/TestDemoBench.java
================
package testbench;

import benchmark.bench.DemoBenchmark;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.ILogger;
import benchmark.logging.TimeUnit;
import benchmark.timing.Timer;

public class TestDemoBench {
    public static void main(String[] args) {
        ILogger log = new ConsoleLogger();
        Timer t = new Timer();
        DemoBenchmark demo = new DemoBenchmark();

        long sleepMs = 100;      // expected 100 ms
        demo.initialize(sleepMs);

        // 1) measure straight sleep + offset %
        t.start();
        demo.run();
        long measuredNs = t.stop();
        double expectedNs = sleepMs * 1_000_000.0;
        double offset = 100.0 * (measuredNs - expectedNs) / expectedNs;
        log.write("Expected (ms):", sleepMs);
        log.write("Measured (ns):", measuredNs);
        log.write(String.format("Offset: %.2f%%", offset));

        // 2) test pause/resume sequence in a loop (six 100 ms sleeps)
        t.start();
        t.pause();  // immediately pause so resume() is valid

        for (int i = 0; i < 6; i++) {
            t.resume();      // now legal, because paused
            try { Thread.sleep(sleepMs); } catch (InterruptedException ignored) {}
            long delta = t.pause();
            log.write("Segment", i, "=", delta / 1_000_000.0, "ms");
        }
        long total = t.stop();   // sum of all six segments
        log.write("Total (ms):", total / 1_000_000.0);

        // 3) now demonstrate writeTime in different units:
        log.writeTime("Total in seconds:", total, TimeUnit.SECOND);
        log.writeTime("Total in millis:", total, TimeUnit.MILLI);
        log.writeTime("Total in micros:", total, TimeUnit.MICRO);
        log.close();
    }
}

================
File: src/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-29T11:59:18.448Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
benchmark/
  bench/
    CpuSortBenchmark.java
    DemoBenchmark.java
    FileWriteBenchmark.java
    IBenchmark.java
  logging/
    ConsoleLogger.java
    FileLogger.java
    ILogger.java
    TimeUnit.java
  timing/
    ITimer.java
    Timer.java
  Main.java
testbench/
  TestDemoBench.java

================================================================
Files
================================================================

================
File: benchmark/bench/CpuSortBenchmark.java
================
package benchmark.bench;

import java.util.Random;

public class CpuSortBenchmark implements IBenchmark {
    private double[] data;
    private volatile boolean cancelled = false;

    @Override
    public void initialize(Object... params) {
        int size = (Integer) params[0];
        data = new double[size];
        Random rnd = new Random();
        for (int i = 0; i < size; i++) {
            data[i] = rnd.nextDouble();
        }
    }

    @Override
    public void run() {
        int n = data.length;
        for (int i = 0; i < n && !cancelled; i++) {
            for (int j = 0; j < n - i - 1 && !cancelled; j++) {
                if (data[j] > data[j + 1]) {
                    double tmp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = tmp;
                }
            }
        }
    }

    @Override
    public void clean() {
        data = null;
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: benchmark/bench/DemoBenchmark.java
================
package benchmark.bench;

public class DemoBenchmark implements IBenchmark {
    private long sleepMillis;
    private volatile boolean cancelled;

    @Override
    public void initialize(Object... params) {
        sleepMillis = (Long) params[0];
        cancelled = false;
    }

    @Override
    public void run() {
        try {
            Thread.sleep(sleepMillis);
        } catch (InterruptedException ignored) {}
    }

    @Override
    public void clean() {
        // nothing to clean
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: benchmark/bench/FileWriteBenchmark.java
================
package benchmark.bench;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class FileWriteBenchmark implements IBenchmark {
    private String filepath;
    private volatile boolean cancelled = false;

    @Override
    public void initialize(Object... params) {
        filepath = (String) params[0];
    }

    @Override
    public void run() {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(filepath))) {
            for (int i = 0; i < 1_000_000 && !cancelled; i++) {
                bw.write("Line " + i);
                bw.newLine();
            }
        } catch (IOException e) {
            throw new RuntimeException("File write failed", e);
        }
    }

    @Override
    public void clean() {
        // nothing extra
    }

    @Override
    public void cancel() {
        cancelled = true;
    }
}

================
File: benchmark/bench/IBenchmark.java
================
package benchmark.bench;

public interface IBenchmark {
    /** Prepare the benchmark (e.g. generate data or open files). */
    void initialize(Object... params);
    /** The actual code whose performance is measured. */
    void run();
    /** Cleanup after run (e.g. free memory). */
    void clean();
    /** Signal cancellation (should cause run() to return as soon as possible). */
    void cancel();
}

================
File: benchmark/logging/ConsoleLogger.java
================
package benchmark.logging;

public class ConsoleLogger implements ILogger {
    @Override
    public void write(long value) {
        System.out.println(value);
    }
    @Override
    public void write(String text) {
        System.out.println(text);
    }
    @Override
    public void write(Object... values) {
        StringBuilder sb = new StringBuilder();
        for (Object v : values) sb.append(v).append(" ");
        System.out.println(sb.toString().trim());
    }
    @Override
    public void close() { /* no-op */ }
}

================
File: benchmark/logging/FileLogger.java
================
package benchmark.logging;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class FileLogger implements ILogger {
    private final BufferedWriter writer;

    public FileLogger(String filepath) throws IOException {
        this.writer = new BufferedWriter(new FileWriter(filepath));
    }

    @Override
    public void write(long value) {
        write(Long.toString(value));
    }

    @Override
    public void write(String text) {
        try {
            writer.write(text);
            writer.newLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void write(Object... values) {
        StringBuilder sb = new StringBuilder();
        for (Object v : values) sb.append(v).append(" ");
        write(sb.toString().trim());
    }

    @Override
    public void close() {
        try { writer.close(); }
        catch (IOException ignored) {}
    }
}

================
File: benchmark/logging/ILogger.java
================
package benchmark.logging;

import benchmark.logging.TimeUnit;

public interface ILogger {
    void write(long value);
    void write(String text);
    void write(Object... values);
    void close();

    /** Convert & write a time value in the given unit. */
    default void writeTime(String label, long nanos, TimeUnit unit) {
        double v = unit.fromNanos(nanos);
        write(label, String.format("%.3f", v), unit.name());
    }
}

================
File: benchmark/logging/TimeUnit.java
================
package benchmark.logging;

/** Supported units for converting nanoseconds. */
public enum TimeUnit {
    NANO   (1L),
    MICRO  (1_000L),
    MILLI  (1_000_000L),
    SECOND (1_000_000_000L);

    private final long factor;

    TimeUnit(long nanosPerUnit) {
        this.factor = nanosPerUnit;
    }

    /** Convert nanoseconds to this unit (returns a double). */
    public double fromNanos(long nanos) {
        return nanos / (double)factor;
    }
}

================
File: benchmark/timing/ITimer.java
================
package benchmark.timing;

public interface ITimer {
    /** Reset any previous time and start timing from now. */
    void start();

    /** Stop timing and return cumulative elapsed nanoseconds. */    
    long stop();
    
    // Pause timing (accumulate since last start) and return the last segment’s nanoseconds.
    long pause();

    // Resume timing after a pause.
    void resume();
}

================
File: benchmark/timing/Timer.java
================
package benchmark.timing;

public class Timer implements ITimer {
    private long startTime;
    private long elapsed;
    private boolean running;
    private boolean started;

    public Timer() {
        this.elapsed = 0;
        this.running = false;
        this.started = false;
    }

    @Override
    public void start() {
        // Always reset
        elapsed = 0;
        startTime = System.nanoTime();
        running = true;
        started = true;
    }

    @Override
    public long pause() {
        if (!started || !running) {
            throw new IllegalStateException("Cannot pause: timer is not running");
        }
        long now = System.nanoTime();
        long delta = now - startTime;
        elapsed += delta;
        running = false;
        return delta;
    }

    @Override
    public void resume() {
        if (!started) {
            throw new IllegalStateException("Cannot resume: timer has not been started");
        }
        if (running) {
            throw new IllegalStateException("Cannot resume: timer is already running");
        }
        startTime = System.nanoTime();
        running = true;
    }

    @Override
    public long stop() {
        if (!started) {
            throw new IllegalStateException("Cannot stop: timer has not been started");
        }
        if (running) {
            long now = System.nanoTime();
            elapsed += now - startTime;
            running = false;
        }
        started = false;
        return elapsed;
    }
}

================
File: benchmark/Main.java
================
package benchmark;

import benchmark.timing.Timer;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.FileLogger;
import benchmark.logging.ILogger;
import benchmark.bench.CpuSortBenchmark;
import benchmark.bench.FileWriteBenchmark;
import benchmark.bench.IBenchmark;

public class Main {
    private static void usage() {
        System.out.println("Usage:");
        System.out.println("  java -jar benchmark.jar --list");
        System.out.println("  java -jar benchmark.jar --benchmark [cpu_sort|file_write] --logger [console|file]");
        System.out.println("       [--logfile <file>] [--size <n>] [--path <file>]");
    }

    private static void listBenchmarks() {
        System.out.println("Available benchmarks:");
        System.out.println("  cpu_sort   - Bubble sort on a random array");
        System.out.println("  file_write - Write 1,000,000 lines to a file");
    }

    public static void main(String[] args) {
        if (args.length == 0) {
            listBenchmarks();
            usage();
            return;
        }

        String benchmark = null, loggerType = null, logfile = null, path = "benchmark_output.txt";
        int size = 10_000;
        for (int i = 0; i < args.length; i++) {
            switch (args[i]) {
                case "--list":
                    listBenchmarks(); return;
                case "--benchmark":
                    benchmark = args[++i]; break;
                case "--logger":
                    loggerType = args[++i]; break;
                case "--logfile":
                    logfile = args[++i]; break;
                case "--size":
                    size = Integer.parseInt(args[++i]); break;
                case "--path":
                    path = args[++i]; break;
                default:
                    System.err.println("Unknown option: " + args[i]);
                    usage();
                    return;
            }
        }

        if (benchmark == null || loggerType == null) {
            System.err.println("Error: --benchmark and --logger are required.");
            usage();
            return;
        }

        IBenchmark bench;
        switch (benchmark) {
            case "cpu_sort":
                bench = new CpuSortBenchmark();
                bench.initialize(size);
                break;
            case "file_write":
                bench = new FileWriteBenchmark();
                bench.initialize(path);
                break;
            default:
                System.err.println("Unknown benchmark: " + benchmark);
                return;
        }

        ILogger logger;
        try {
            switch (loggerType) {
                case "console":
                    logger = new ConsoleLogger();
                    break;
                case "file":
                    if (logfile == null) {
                        System.err.println("Error: --logfile is required for file logger.");
                        return;
                    }
                    logger = new FileLogger(logfile);
                    break;
                default:
                    System.err.println("Unknown logger: " + loggerType);
                    return;
            }
        } catch (Exception e) {
            System.err.println("Failed to initialize logger: " + e.getMessage());
            return;
        }

        Timer timer = new Timer();
        timer.start();
        bench.run();
        long elapsedNs = timer.stop();
        double elapsedMs = elapsedNs / 1_000_000.0;

        logger.write("Benchmark:", benchmark);
        logger.write("Elapsed (ns):", elapsedNs);
        logger.write("Elapsed (ms):", String.format("%.3f", elapsedMs));
        logger.close();
        bench.clean();
    }
}

================
File: testbench/TestDemoBench.java
================
package testbench;

import benchmark.bench.DemoBenchmark;
import benchmark.logging.ConsoleLogger;
import benchmark.logging.ILogger;
import benchmark.logging.TimeUnit;
import benchmark.timing.Timer;

public class TestDemoBench {
    public static void main(String[] args) {
        ILogger log = new ConsoleLogger();
        Timer t = new Timer();
        DemoBenchmark demo = new DemoBenchmark();

        long sleepMs = 100;      // expected 100 ms
        demo.initialize(sleepMs);

        // 1) measure straight sleep + offset %
        t.start();
        demo.run();
        long measuredNs = t.stop();
        double expectedNs = sleepMs * 1_000_000.0;
        double offset = 100.0 * (measuredNs - expectedNs) / expectedNs;
        log.write("Expected (ms):", sleepMs);
        log.write("Measured (ns):", measuredNs);
        log.write(String.format("Offset: %.2f%%", offset));

        // 2) test pause/resume sequence in a loop (six 100 ms sleeps)
        t.start();
        for (int i = 0; i < 6; i++) {
            t.resume();      // error if already running
            try { Thread.sleep(sleepMs); } catch(Exception ignored){}
            long delta = t.pause();
            log.write("Segment", i, "=", delta / 1_000_000.0, "ms");
        }
        long total = t.stop();   // sum of all six segments
        log.write("Total (ms):", total / 1_000_000.0);

        // 3) now demonstrate writeTime in different units:
        log.writeTime("Total in seconds:", total, TimeUnit.SECOND);
        log.writeTime("Total in millis:", total, TimeUnit.MILLI);
        log.writeTime("Total in micros:", total, TimeUnit.MICRO);
        log.close();
    }
}

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: README.md
================
# Simple Benchmark Framework

A tiny Java tool to time code and log results.

## Quick Start

# 1. Compile everything (no output if successful)
javac -d bin \
  src/benchmark/timing/*.java \
  src/benchmark/logging/*.java \
  src/benchmark/bench/*.java \
  src/benchmark/Main.java \
  src/testbench/TestDemoBench.java

# 2. List available benchmarks
java -cp bin benchmark.Main --list

Available benchmarks:
  cpu_sort   - Bubble sort on a random array
  file_write - Write 1,000,000 lines to a file

# 3. Run CPU‐sort with console logger
java -cp bin benchmark.Main --benchmark cpu_sort --logger console --size 5000

Benchmark: cpu_sort
Elapsed (ns): 123456789
Elapsed (ms): 123.457

# 4. Run CPU‐sort with file logger
java -cp bin benchmark.Main --benchmark cpu_sort --logger file --logfile cpu_log.txt --size 5000

# → no console output, but cpu_log.txt contains:
# Benchmark: cpu_sort
# Elapsed (ns): 123456789
# Elapsed (ms): 123.457

# 5. Run file‐write with console logger
java -cp bin benchmark.Main --benchmark file_write --logger console --path demo_output.txt

Benchmark: file_write
Elapsed (ns): 987654321
Elapsed (ms): 987.654

# 6. Run file‐write with file logger
java -cp bin benchmark.Main --benchmark file_write --logger file --logfile file_log.txt --path demo_output.txt

# → no console output, but file_log.txt contains:
# Benchmark: file_write
# Elapsed (ns): 987654321
# Elapsed (ms): 987.654

# 7. Run the demo/testbench
java -cp bin testbench.TestDemoBench

Expected (ms): 100
Measured (ns): 105416458
Offset: 5.42%

Segment 0 = 105.048166 ms
Segment 1 = 105.04525 ms
Segment 2 = 102.262583 ms
Segment 3 = 105.0355 ms
Segment 4 = 101.854875 ms
Segment 5 = 104.297 ms
Total (ms): 623.546082
Total in seconds: 0.624 SECOND
Total in millis: 623.546 MILLI
Total in micros: 623546.082 MICRO
